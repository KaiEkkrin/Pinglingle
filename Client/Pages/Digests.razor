@page "/digests/{date:datetime}"

@inject HttpClient Http

<PageTitle>Digests</PageTitle>

<h1>Digests</h1>

@foreach (var (address, digests) in _digestsByAddress)
{
    <DigestChart Title=@address Digests=@digests />
}

<div class="container">
    <div class="row">
        <div class="col"></div>
        <div class="col">
            @(Date.ToShortDateString())
        </div>
        <div class="col"></div>
    </div>
</div>

@code {
    private readonly DateTime _maxDate = DateTimeOffset.Now.Date;

    private SortedDictionary<string, List<Digest>> _digestsByAddress = new();
    private Dictionary<long, Target> _targetsById = new();

    [Parameter]
    public DateTime Date { get; set; }

    private DateTime MinDate => _maxDate.AddDays(-6);

    protected override async Task OnInitializedAsync()
    {
        _targetsById = await GetTargetsAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        // TODO For now this won't be responsive -- you'll need to reload the page to
        // see updated entries. That should be okay
        // Fetch the digests.
        var oldest = new DateTimeOffset(Date).ToUnixTimeSeconds();
        var newest = new DateTimeOffset(Date).AddDays(1).ToUnixTimeSeconds();
        var response = await Http.GetFromJsonAsync<List<Digest>>(
            $"Digests?oldest={oldest}&newest={newest}");
        if (response is { } digests)
        {
            foreach (var g in response.GroupBy(d => d.TargetId))
            {
                if (g.Key is not { } targetId ||
                    !_targetsById.TryGetValue(targetId, out var target)) continue;

                _digestsByAddress[target.Address] = g.ToList();
            }
        }
    }

    private async Task<Dictionary<long, Target>> GetTargetsAsync()
    {
        var response = await Http.GetFromJsonAsync<List<Target>>("Targets");
        if (response is { } targets)
        {
            return targets.ToDictionary(t => t.Id);
        }

        return new Dictionary<long, Target>();
    }
}